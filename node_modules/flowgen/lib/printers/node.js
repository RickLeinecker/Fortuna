"use strict";

exports.__esModule = true;
exports.printEntityName = printEntityName;
exports.printPropertyAccessExpression = printPropertyAccessExpression;
exports.getLeftMostPropertyAccessExpression = getLeftMostPropertyAccessExpression;
exports.getFullyQualifiedPropertyAccessExpression = getFullyQualifiedPropertyAccessExpression;
exports.getFullyQualifiedName = getFullyQualifiedName;
exports.getTypeofFullyQualifiedName = getTypeofFullyQualifiedName;
exports.fixDefaultTypeArguments = fixDefaultTypeArguments;
exports.default = exports.printType = void 0;

var ts = _interopRequireWildcard(require("typescript"));

var _index = _interopRequireDefault(require("./index"));

var _checker = require("../checker");

var logger = _interopRequireWildcard(require("../logger"));

var _env = require("../env");

var _smartIdentifiers = require("./smart-identifiers");

var _errorMessage = require("../errors/error-message");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function printEntityName(type) {
  if (type.kind === ts.SyntaxKind.QualifiedName) {
    return _index.default.relationships.namespace(type.left.kind === ts.SyntaxKind.Identifier ? type.left.text : printEntityName(type.left)) + printEntityName(type.right);
  } else if (type.kind === ts.SyntaxKind.Identifier) {
    return _index.default.relationships.namespace(type.text, true);
  } else {
    return "";
  }
}

function printPropertyAccessExpression(type) {
  if (type.kind === ts.SyntaxKind.PropertyAccessExpression) {
    return _index.default.relationships.namespace(type.expression.kind === ts.SyntaxKind.Identifier ? type.expression.text : printPropertyAccessExpression(type.expression)) + printPropertyAccessExpression(type.name);
  } else if (type.kind === ts.SyntaxKind.Identifier) {
    return _index.default.relationships.namespace(_index.default.identifiers.print(type.text), true);
  } else {
    return "";
  }
}

function getLeftMostPropertyAccessExpression(type) {
  if (type.kind === ts.SyntaxKind.PropertyAccessExpression) {
    return type.expression.kind === ts.SyntaxKind.Identifier ? type.expression : getLeftMostPropertyAccessExpression(type.expression);
  } else if (type.kind === ts.SyntaxKind.Identifier) {
    return type;
  }
}

function getFullyQualifiedPropertyAccessExpression(symbol, type, delimiter = "$") {
  if (_checker.checker.current) {
    var _symbol$parent, _symbol$parent$valueD, _symbol$parent2, _symbol$parent2$value, _symbol$parent3;

    const typeChecker = _checker.checker.current;
    let isExternalSymbol = false;
    const leftMost = getLeftMostPropertyAccessExpression(type);

    if (leftMost) {
      //$todo Flow has problems when switching variables instead of literals
      const leftMostSymbol = typeChecker.getSymbolAtLocation(leftMost);
      const decl = leftMostSymbol ? leftMostSymbol.declarations[0] : {};
      isExternalSymbol = decl.kind === ts.SyntaxKind.NamespaceImport || decl.kind === ts.SyntaxKind.NamedImports;
    }

    if (!symbol || typeChecker.isUnknownSymbol(symbol) || isExternalSymbol) {
      return printPropertyAccessExpression(type);
    }

    if (((_symbol$parent = symbol.parent) === null || _symbol$parent === void 0 ? void 0 : (_symbol$parent$valueD = _symbol$parent.valueDeclaration) === null || _symbol$parent$valueD === void 0 ? void 0 : _symbol$parent$valueD.kind) === ts.SyntaxKind.SourceFile || ((_symbol$parent2 = symbol.parent) === null || _symbol$parent2 === void 0 ? void 0 : (_symbol$parent2$value = _symbol$parent2.valueDeclaration) === null || _symbol$parent2$value === void 0 ? void 0 : _symbol$parent2$value.kind) === ts.SyntaxKind.ModuleDeclaration && (((_symbol$parent3 = symbol.parent) === null || _symbol$parent3 === void 0 ? void 0 : _symbol$parent3.valueDeclaration.flags) & ts.NodeFlags.Namespace) === 0) {
      return typeChecker.symbolToString(symbol);
    } // if (
    //   (symbol.flags & ts.SymbolFlags.ValueModule) ===
    //   ts.SymbolFlags.ValueModule
    // ) {
    //   return typeChecker.symbolToString(
    //     symbol,
    //     undefined,
    //     /*meaning*/ undefined,
    //     ts.SymbolFormatFlags.DoNotIncludeSymbolChain |
    //       ts.SymbolFormatFlags.AllowAnyNodeKind,
    //   );
    // }


    return symbol.parent ? getFullyQualifiedPropertyAccessExpression(symbol.parent, type, delimiter) + delimiter + typeChecker.symbolToString(symbol) : typeChecker.symbolToString(symbol, undefined,
    /*meaning*/
    undefined, //$todo Some problem about TypeScript enums conversion and bitwise operators
    ts.SymbolFormatFlags.DoNotIncludeSymbolChain | ts.SymbolFormatFlags.AllowAnyNodeKind);
  } else {
    return printPropertyAccessExpression(type);
  }
}

function getFullyQualifiedName(symbol, type, checks = true, delimiter = "$") {
  if (_checker.checker.current) {
    var _symbol$parent4, _symbol$parent4$value, _symbol$parent5, _symbol$parent5$value, _symbol$parent6, _symbol$valueDeclarat;

    const typeChecker = _checker.checker.current;

    if (checks) {
      let isExternalSymbol = false;
      const leftMost = (0, _smartIdentifiers.getLeftMostEntityName)(type);

      if (leftMost) {
        var _leftMostSymbol$paren;

        //$todo Flow has problems when switching variables instead of literals
        const leftMostSymbol = typeChecker.getSymbolAtLocation(leftMost);
        const decl = leftMostSymbol ? leftMostSymbol.declarations[0] : {};
        isExternalSymbol = decl.kind === ts.SyntaxKind.NamespaceImport || decl.kind === ts.SyntaxKind.NamedImports || decl.kind === ts.SyntaxKind.TypeParameter || (leftMostSymbol === null || leftMostSymbol === void 0 ? void 0 : (_leftMostSymbol$paren = leftMostSymbol.parent) === null || _leftMostSymbol$paren === void 0 ? void 0 : _leftMostSymbol$paren.escapedName) === "__global";
      }

      if (!symbol || typeChecker.isUnknownSymbol(symbol) || isExternalSymbol) {
        return printEntityName(type);
      }
    }

    if (((_symbol$parent4 = symbol.parent) === null || _symbol$parent4 === void 0 ? void 0 : (_symbol$parent4$value = _symbol$parent4.valueDeclaration) === null || _symbol$parent4$value === void 0 ? void 0 : _symbol$parent4$value.kind) === ts.SyntaxKind.SourceFile || ((_symbol$parent5 = symbol.parent) === null || _symbol$parent5 === void 0 ? void 0 : (_symbol$parent5$value = _symbol$parent5.valueDeclaration) === null || _symbol$parent5$value === void 0 ? void 0 : _symbol$parent5$value.kind) === ts.SyntaxKind.ModuleDeclaration && (((_symbol$parent6 = symbol.parent) === null || _symbol$parent6 === void 0 ? void 0 : _symbol$parent6.valueDeclaration.flags) & ts.NodeFlags.Namespace) === 0) {
      return typeChecker.symbolToString(symbol);
    } // if (
    //   (symbol.flags & ts.SymbolFlags.ValueModule) ===
    //   ts.SymbolFlags.ValueModule
    // ) {
    //   return typeChecker.symbolToString(
    //     symbol,
    //     undefined,
    //     /*meaning*/ undefined,
    //     ts.SymbolFormatFlags.DoNotIncludeSymbolChain |
    //       ts.SymbolFormatFlags.AllowAnyNodeKind,
    //   );
    // }


    if (((_symbol$valueDeclarat = symbol.valueDeclaration) === null || _symbol$valueDeclarat === void 0 ? void 0 : _symbol$valueDeclarat.kind) === ts.SyntaxKind.EnumMember) delimiter = ".";
    return symbol.parent ? getFullyQualifiedName(symbol.parent, type, true, delimiter) + delimiter + typeChecker.symbolToString(symbol) : typeChecker.symbolToString(symbol, undefined,
    /*meaning*/
    undefined, //$todo Some problem about TypeScript enums conversion and bitwise operators
    ts.SymbolFormatFlags.DoNotIncludeSymbolChain | ts.SymbolFormatFlags.AllowAnyNodeKind);
  } else {
    return printEntityName(type);
  }
}

function getTypeofFullyQualifiedName(symbol, type, delimiter = ".") {
  if (_checker.checker.current) {
    var _symbol$parent7, _symbol$parent7$value, _symbol$parent8, _symbol$parent8$value, _symbol$parent9, _symbol$parent10;

    const typeChecker = _checker.checker.current;
    let isExternalSymbol = false;
    const leftMost = (0, _smartIdentifiers.getLeftMostEntityName)(type);

    if (leftMost) {
      //$todo Flow has problems when switching variables instead of literals
      const leftMostSymbol = typeChecker.getSymbolAtLocation(leftMost);
      const decl = leftMostSymbol ? leftMostSymbol.declarations[0] : {};
      isExternalSymbol = decl.kind === ts.SyntaxKind.NamespaceImport || decl.kind === ts.SyntaxKind.NamedImports;
    }

    if (!symbol || typeChecker.isUnknownSymbol(symbol) || isExternalSymbol) {
      return printEntityName(type);
    }

    if (((_symbol$parent7 = symbol.parent) === null || _symbol$parent7 === void 0 ? void 0 : (_symbol$parent7$value = _symbol$parent7.valueDeclaration) === null || _symbol$parent7$value === void 0 ? void 0 : _symbol$parent7$value.kind) === ts.SyntaxKind.SourceFile || ((_symbol$parent8 = symbol.parent) === null || _symbol$parent8 === void 0 ? void 0 : (_symbol$parent8$value = _symbol$parent8.valueDeclaration) === null || _symbol$parent8$value === void 0 ? void 0 : _symbol$parent8$value.kind) === ts.SyntaxKind.ModuleDeclaration && (((_symbol$parent9 = symbol.parent) === null || _symbol$parent9 === void 0 ? void 0 : _symbol$parent9.valueDeclaration.flags) & ts.NodeFlags.Namespace) === 0) {
      return typeChecker.symbolToString(symbol);
    }

    if (((_symbol$parent10 = symbol.parent) === null || _symbol$parent10 === void 0 ? void 0 : _symbol$parent10.escapedName) === "__type") {
      return symbol.parent ? getTypeofFullyQualifiedName(symbol.parent.declarations[0].parent.symbol, type) + delimiter + typeChecker.symbolToString(symbol) : typeChecker.symbolToString(symbol, undefined,
      /*meaning*/
      undefined, //$todo Some problem about TypeScript enums conversion and bitwise operators
      ts.SymbolFormatFlags.DoNotIncludeSymbolChain | ts.SymbolFormatFlags.AllowAnyNodeKind);
    } else {
      var _symbol$valueDeclarat2;

      let delimiter = "$";

      if (((_symbol$valueDeclarat2 = symbol.valueDeclaration) === null || _symbol$valueDeclarat2 === void 0 ? void 0 : _symbol$valueDeclarat2.kind) === ts.SyntaxKind.EnumMember) {
        delimiter = ".";
      }

      return symbol.parent ? getTypeofFullyQualifiedName(symbol.parent, type, delimiter) + delimiter + typeChecker.symbolToString(symbol) : typeChecker.symbolToString(symbol, undefined,
      /*meaning*/
      undefined, //$todo Some problem about TypeScript enums conversion and bitwise operators
      ts.SymbolFormatFlags.DoNotIncludeSymbolChain | ts.SymbolFormatFlags.AllowAnyNodeKind);
    }
  } else {
    return printEntityName(type);
  }
}

function fixDefaultTypeArguments(symbol, type) {
  var _decl$typeParameters;

  if (!symbol) return;
  if (!symbol.declarations) return;
  const decl = symbol.declarations[0];
  const allTypeParametersHaveDefaults = !!(decl === null || decl === void 0 ? void 0 : (_decl$typeParameters = decl.typeParameters) === null || _decl$typeParameters === void 0 ? void 0 : _decl$typeParameters.length) && decl.typeParameters.every(param => !!param.default);

  if (allTypeParametersHaveDefaults && !type.typeArguments) {
    type.typeArguments = [];
  }
}

const printType = (0, _env.withEnv)((env, rawType) => {
  var _type$qualifier;

  // debuggerif()
  //TODO: #6 No match found in SyntaxKind enum
  const type = rawType;
  const keywordPrefix = type.modifiers && type.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.StaticKeyword) ? "static " : "";
  const kind = ts.SyntaxKind[type.kind].toString();

  switch (type.kind) {
    case ts.SyntaxKind.VoidKeyword:
      return _index.default.basics.print(kind);

    case ts.SyntaxKind.StringKeyword:
      return _index.default.basics.print(kind);

    case ts.SyntaxKind.AnyKeyword:
      return _index.default.basics.print(kind);

    case ts.SyntaxKind.NumberKeyword:
      return _index.default.basics.print(kind);

    case ts.SyntaxKind.BooleanKeyword:
      return _index.default.basics.print(kind);

    case ts.SyntaxKind.NullKeyword:
      return _index.default.basics.print(kind);

    case ts.SyntaxKind.UndefinedKeyword:
      return _index.default.basics.print(kind);

    case ts.SyntaxKind.ObjectKeyword:
      return _index.default.basics.print(kind);

    case ts.SyntaxKind.FalseKeyword:
      return _index.default.basics.print(kind);

    case ts.SyntaxKind.TrueKeyword:
      return _index.default.basics.print(kind);

    case ts.SyntaxKind.NeverKeyword:
      return _index.default.basics.print(kind);

    case ts.SyntaxKind.UnknownKeyword:
      return _index.default.basics.print(kind);

    case ts.SyntaxKind.SymbolKeyword:
      // TODO: What to print here?
      return "Symbol";

    case ts.SyntaxKind.BigIntKeyword:
      logger.error(type, {
        type: "UnsupportedBigInt"
      }); // TODO: What to print here?

      return "number";
    // JSDoc types
    //$todo some weird union errors

    case ts.SyntaxKind.JSDocAllType:
      return "*";
    //$todo some weird union errors

    case ts.SyntaxKind.JSDocUnknownType:
      return "?";
    //$todo some weird union errors

    case ts.SyntaxKind.JSDocOptionalType:
      return printType(type.type) + "=";
    //$todo some weird union errors

    case ts.SyntaxKind.JSDocFunctionType:
      {
        const params = type.parameters.map(param => printType(param.type)).join(", ");
        const ret = type.type ? `: ${printType(type.type)}` : "";
        return `function(${params})${ret}`;
      }
    //$todo some weird union errors

    case ts.SyntaxKind.JSDocTypeLiteral:
      return "object";
    //$todo some weird union errors

    case ts.SyntaxKind.JSDocVariadicType:
      return "..." + printType(type.type);
    //$todo some weird union error

    case ts.SyntaxKind.JSDocNonNullableType:
      return "!" + printType(type.type);
    //$todo some weird union errors

    case ts.SyntaxKind.JSDocNullableType:
      return "?" + printType(type.type);

    case ts.SyntaxKind.ConditionalType:
      {
        const error = {
          type: "UnsupportedConditionalType"
        };
        logger.error(type, error);

        if (env && env.tsdoc) {
          return `any`;
        }

        return `/* ${(0, _errorMessage.printErrorMessage)(error)} */ any`;
      }
    //$todo some weird union errors

    case ts.SyntaxKind.ComputedPropertyName:
      {
        var _type$expression, _type$expression$expr, _type$expression2, _type$expression2$nam, _type$expression3, _type$expression3$exp, _type$expression4, _type$expression4$nam;

        if (((_type$expression = type.expression) === null || _type$expression === void 0 ? void 0 : (_type$expression$expr = _type$expression.expression) === null || _type$expression$expr === void 0 ? void 0 : _type$expression$expr.text) === "Symbol" && ((_type$expression2 = type.expression) === null || _type$expression2 === void 0 ? void 0 : (_type$expression2$nam = _type$expression2.name) === null || _type$expression2$nam === void 0 ? void 0 : _type$expression2$nam.text) === "iterator") {
          return "@@iterator";
        }

        if (((_type$expression3 = type.expression) === null || _type$expression3 === void 0 ? void 0 : (_type$expression3$exp = _type$expression3.expression) === null || _type$expression3$exp === void 0 ? void 0 : _type$expression3$exp.text) === "Symbol" && ((_type$expression4 = type.expression) === null || _type$expression4 === void 0 ? void 0 : (_type$expression4$nam = _type$expression4.name) === null || _type$expression4$nam === void 0 ? void 0 : _type$expression4$nam.text) === "asyncIterator") {
          return "@@asyncIterator";
        }

        if (type.expression.kind === ts.SyntaxKind.StringLiteral) {
          return printType(type.expression);
        }

        logger.error(type.expression, {
          type: "UnsupportedComputedProperty"
        });
        return `[typeof ${printType(type.expression)}]`;
      }

    case ts.SyntaxKind.FunctionType:
      //case SyntaxKind.FunctionTypeAnnotation:
      return _index.default.functions.functionType(type);

    case ts.SyntaxKind.TypeLiteral:
      return _index.default.declarations.interfaceType(type, false, true);
    //case SyntaxKind.IdentifierObject:
    //case SyntaxKind.StringLiteralType:

    case ts.SyntaxKind.Identifier:
      {
        return _index.default.relationships.namespace(_index.default.identifiers.print(type.text), true);
      }

    case ts.SyntaxKind.BindingElement:
      return _index.default.common.typeParameter(type);

    case ts.SyntaxKind.TypeParameter:
      return _index.default.common.typeParameter(type);

    case ts.SyntaxKind.PrefixUnaryExpression:
      switch (type.operator) {
        case ts.SyntaxKind.MinusToken:
          return `-${type.operand.text}`;

        default:
          console.log('"NO PRINT IMPLEMENTED: PrefixUnaryExpression"');
          return '"NO PRINT IMPLEMENTED: PrefixUnaryExpression"';
      }

    case ts.SyntaxKind.TypePredicate:
      //TODO: replace with boolean %checks when supported in class declarations
      return "boolean";

    case ts.SyntaxKind.IndexedAccessType:
      {
        let fn = "$ElementType";

        if (type.indexType.kind === ts.SyntaxKind.LiteralType && type.indexType.literal.kind === ts.SyntaxKind.StringLiteral) {
          fn = "$PropertyType";
        }

        return `${fn}<${printType(type.objectType)}, ${printType(type.indexType)}>`;
      }

    case ts.SyntaxKind.TypeOperator:
      switch (type.operator) {
        case ts.SyntaxKind.KeyOfKeyword:
          return `$Keys<${printType(type.type)}>`;

        case ts.SyntaxKind.UniqueKeyword:
          logger.error(type, {
            type: "UnsupportedUniqueSymbol"
          });
          return printType(type.type);

        case ts.SyntaxKind.ReadonlyKeyword:
          if (type.type.kind === ts.SyntaxKind.ArrayType) {
            return `$ReadOnlyArray<${printType(type.type.elementType)}>`;
          } else if (type.type.kind === ts.SyntaxKind.TupleType) {
            return printType(type.type);
          } else {
            const error = {
              type: "UnsupportedTypeOperator",
              operator: type.operator
            };
            logger.error(type, error);
            return `/* ${(0, _errorMessage.printErrorMessage)(error)} */ any`;
          }

        default:
          {
            const error = {
              type: "UnsupportedTypeOperator",
              operator: type.operator
            };
            logger.error(type, error);
            return `/* ${(0, _errorMessage.printErrorMessage)(error)} */ any`;
          }
      }

    case ts.SyntaxKind.MappedType:
      {
        const constraint = type.typeParameter.constraint;
        const typeName = printType(type.typeParameter.name);
        const value = printType(type.type);
        let source = `{[k: ${printType(constraint)}]: any}`;

        if (constraint.operator === ts.SyntaxKind.KeyOfKeyword) {
          source = printType(constraint.type);
        }

        return `$ObjMapi<${source}, <${typeName}>(${typeName}) => ${value}>`;
      }

    case ts.SyntaxKind.FirstLiteralToken:
      return type.text;

    case ts.SyntaxKind.ImportType:
      if ((_type$qualifier = type.qualifier) === null || _type$qualifier === void 0 ? void 0 : _type$qualifier.escapedText) {
        return `$PropertyType<$Exports<${printType(type.argument)}>, ${JSON.stringify(type.qualifier.escapedText)}>`;
      }

      return `$Exports<${printType(type.argument)}>`;

    case ts.SyntaxKind.FirstTypeNode:
      return _index.default.common.literalType(type);

    case ts.SyntaxKind.LastTypeNode:
      return _index.default.common.literalType(type);

    case ts.SyntaxKind.LiteralType:
      return _index.default.common.literalType(type);

    case ts.SyntaxKind.QualifiedName:
      {
        let symbol;

        if (_checker.checker.current) {
          //$todo
          symbol = _checker.checker.current.getSymbolAtLocation(type);
        }

        return getFullyQualifiedName(symbol, type);
      }

    case ts.SyntaxKind.StringLiteral:
      return JSON.stringify(type.text);

    case ts.SyntaxKind.TypeReference:
      {
        let symbol;

        if (_checker.checker.current) {
          //$todo
          symbol = _checker.checker.current.getSymbolAtLocation(type.typeName);
          fixDefaultTypeArguments(symbol, type);
          const isRenamed = (0, _smartIdentifiers.renames)(symbol, type);

          if (symbol && symbol.declarations && symbol.declarations[0].kind === ts.SyntaxKind.EnumMember) {
            return `typeof ${getTypeofFullyQualifiedName(symbol, type.typeName)}`;
          } else if (symbol && symbol.declarations && symbol.declarations[0].kind === ts.SyntaxKind.EnumDeclaration) {
            return `$Values<typeof ${getTypeofFullyQualifiedName(symbol, type.typeName)}>`;
          }

          if (!isRenamed) {
            //$todo weird union errors
            type.typeName.escapedText = getFullyQualifiedName(symbol, type.typeName);
          }
        }

        return _index.default.declarations.typeReference(type, !symbol);
      }

    case ts.SyntaxKind.VariableDeclaration:
      return _index.default.declarations.propertyDeclaration(type, keywordPrefix, true);

    case ts.SyntaxKind.PropertyDeclaration:
      return _index.default.declarations.propertyDeclaration(type, keywordPrefix);
    //$todo some weird union errors

    case ts.SyntaxKind.OptionalType:
      return `${printType(type.type)} | void`;

    case ts.SyntaxKind.TupleType:
      {
        const lastElement = type.elementTypes[type.elementTypes.length - 1];
        if (lastElement && lastElement.kind === ts.SyntaxKind.RestType) type.elementTypes.pop();
        let tuple = `[${type.elementTypes.map(printType).join(", ")}]`;

        if (lastElement && lastElement.kind === ts.SyntaxKind.RestType) {
          tuple += ` & ${printType(lastElement.type)}`;
        }

        return tuple;
      }

    case ts.SyntaxKind.MethodSignature:
      return _index.default.common.methodSignature(type);

    case ts.SyntaxKind.ExpressionWithTypeArguments:
      return printType(type.expression) + _index.default.common.generics(type.typeArguments);

    case ts.SyntaxKind.PropertyAccessExpression:
      return getFullyQualifiedPropertyAccessExpression( //$todo some weird union errors
      _checker.checker.current.getSymbolAtLocation(type), type);
    // case SyntaxKind.NodeObject:
    //   return (
    //     printers.relationships.namespace(type.expression.text) +
    //     printType(type.name)
    //   );

    case ts.SyntaxKind.PropertySignature:
      return _index.default.common.parameter(type);

    case ts.SyntaxKind.CallSignature:
      {
        // TODO: rewrite to printers.functions.functionType
        const generics = _index.default.common.generics(type.typeParameters, node => {
          node.withoutDefault = true;
          return node;
        });

        const str = `${generics}(${type.parameters.filter(param => param.name.text !== "this").map(_index.default.common.parameter).join(", ")})`; // TODO: I can't understand this

        return type.type ? `${str}: ${printType(type.type)}` : `${str}: any`;
      }

    case ts.SyntaxKind.UnionType:
      {
        const join = type.types.length >= 5 ? "\n" : " "; // debugger

        return type.types.map(printType).join(`${join}| `);
      }

    case ts.SyntaxKind.ArrayType:
      return printType(type.elementType) + "[]";

    case ts.SyntaxKind.ThisType:
      return "this";

    case ts.SyntaxKind.IndexSignature:
      if (type.type) {
        return `[${type.parameters.map(_index.default.common.parameter).join(", ")}]: ${printType(type.type)}`;
      }

      return "";

    case ts.SyntaxKind.IntersectionType:
      return type.types.map(printType).join(" & ");

    case ts.SyntaxKind.MethodDeclaration:
      // Skip methods marked as private
      if (type.modifiers && type.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.PrivateKeyword)) {
        return "";
      }

      return keywordPrefix + _index.default.common.methodSignature(type);

    case ts.SyntaxKind.ConstructorType:
      // Not implemented. The return is just a guess.
      return "(" + type.parameters.map(_index.default.common.parameter).join(", ") + ") => " + printType(type.type);

    case ts.SyntaxKind.ConstructSignature:
      return "new " + _index.default.functions.functionType(type, true);

    case ts.SyntaxKind.TypeQuery:
      {
        //$todo some weird union errors
        const symbol = _checker.checker.current.getSymbolAtLocation(type.exprName);

        return "typeof " + getTypeofFullyQualifiedName(symbol, type.exprName);
      }

    case ts.SyntaxKind.Constructor:
      return "constructor(" + type.parameters.map(_index.default.common.parameter).join(", ") + "): this";

    case ts.SyntaxKind.ParenthesizedType:
      return `(${printType(type.type)})`;

    case ts.SyntaxKind.ImportSpecifier:
      if (_checker.checker.current) {
        //$todo some weird union errors
        const symbol = _checker.checker.current.getSymbolAtLocation(type.name);

        (0, _smartIdentifiers.renames)(symbol, type);
      }

      return _index.default.relationships.importExportSpecifier(type);

    case ts.SyntaxKind.ExportSpecifier:
      return _index.default.relationships.importExportSpecifier(type);

    default:
      type.kind;
  }

  const output = `/* NO PRINT IMPLEMENTED: ${ts.SyntaxKind[type.kind]} */ any`;
  console.log(output);
  return output;
});
exports.printType = printType;
var _default = printType;
exports.default = _default;