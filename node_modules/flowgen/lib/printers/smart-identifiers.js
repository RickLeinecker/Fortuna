"use strict";

exports.__esModule = true;
exports.renames = renames;
exports.getLeftMostEntityName = getLeftMostEntityName;

var ts = _interopRequireWildcard(require("typescript"));

var _checker = require("../checker");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const setImportedName = (name, type, symbol, decl) => {
  var _symbol$parent, _decl$parent, _decl$parent$parent, _decl$parent$parent$p, _decl$parent$parent$p2;

  const specifiers = ["react"];
  const namespaces = ["React"];

  const paths = name => {
    if (name === "react" || name === "React") {
      return {
        ReactNode: "Node"
      };
    }

    return {};
  };

  if (namespaces.includes((_symbol$parent = symbol.parent) === null || _symbol$parent === void 0 ? void 0 : _symbol$parent.escapedName)) {
    var _symbol$parent2;

    type.escapedText = paths((_symbol$parent2 = symbol.parent) === null || _symbol$parent2 === void 0 ? void 0 : _symbol$parent2.escapedName)[name] || name;
    return true;
  } else if (specifiers.includes((_decl$parent = decl.parent) === null || _decl$parent === void 0 ? void 0 : (_decl$parent$parent = _decl$parent.parent) === null || _decl$parent$parent === void 0 ? void 0 : (_decl$parent$parent$p = _decl$parent$parent.parent) === null || _decl$parent$parent$p === void 0 ? void 0 : (_decl$parent$parent$p2 = _decl$parent$parent$p.moduleSpecifier) === null || _decl$parent$parent$p2 === void 0 ? void 0 : _decl$parent$parent$p2.text)) {
    type.escapedText = paths(decl.parent.parent.parent.moduleSpecifier.text)[name] || name;
    return true;
  }

  return false;
};

const setGlobalName = (type, _symbol) => {
  const globals = [{
    from: ts.createQualifiedName(ts.createIdentifier("JSX"), "Element"),
    to: ts.createIdentifier("React$Node")
  }];

  if (_checker.checker.current) {
    const bools = [];

    for (const _ref of globals) {
      const {
        from,
        to
      } = _ref;

      if (compareQualifiedName(type.typeName, from)) {
        type.typeName = to;
        bools.push(true);
      }
    }

    return bools.length > 0;
  }

  return false;
};

function renames(symbol, type) {
  if (!symbol) return false;
  if (!symbol.declarations) return false;
  let decl = symbol.declarations[0];

  if (type.parent.kind === ts.SyntaxKind.NamedImports) {
    setImportedName(decl.name.escapedText, decl.name, symbol, decl);
  } else if (type.kind === ts.SyntaxKind.TypeReference) {
    const leftMost = getLeftMostEntityName(type.typeName);

    if (leftMost && _checker.checker.current) {
      var _leftMostSymbol$paren;

      const leftMostSymbol = _checker.checker.current.getSymbolAtLocation(leftMost);

      const isGlobal = (leftMostSymbol === null || leftMostSymbol === void 0 ? void 0 : (_leftMostSymbol$paren = leftMostSymbol.parent) === null || _leftMostSymbol$paren === void 0 ? void 0 : _leftMostSymbol$paren.escapedName) === "__global";

      if (isGlobal) {
        return setGlobalName(type, symbol);
      }
    }

    if (type.typeName.right) {
      return setImportedName(symbol.escapedName, type.typeName.right, symbol, decl);
    } else {
      return setImportedName(symbol.escapedName, type.typeName, symbol, decl);
    }
  }

  return false;
}

function getLeftMostEntityName(type) {
  if (type.kind === ts.SyntaxKind.QualifiedName) {
    return type.left.kind === ts.SyntaxKind.Identifier ? type.left : getLeftMostEntityName(type.left);
  } else if (type.kind === ts.SyntaxKind.Identifier) {
    return type;
  }
}

function compareIdentifier(a, b) {
  if (a.kind !== b.kind) return false;
  if (a.escapedText === b.escapedText && a.text === b.text) return true;
  return false;
}

function compareEntityName(a, b) {
  if (a.kind === ts.SyntaxKind.Identifier && b.kind === ts.SyntaxKind.Identifier) {
    return compareIdentifier(a, b);
  }

  if (a.kind === ts.SyntaxKind.QualifiedName && b.kind === ts.SyntaxKind.QualifiedName) {
    return compareQualifiedName(a, b);
  }

  return false;
}

function compareQualifiedName(a, b) {
  if (a.kind !== b.kind) return false;
  return compareEntityName(a.left, b.left) && compareIdentifier(a.right, b.right);
}