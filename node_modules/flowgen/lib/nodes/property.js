"use strict";

exports.__esModule = true;
exports.default = void 0;

var ts = _interopRequireWildcard(require("typescript"));

var _node = _interopRequireDefault(require("./node"));

var _printers = _interopRequireDefault(require("../printers"));

var _namespaceManager = _interopRequireDefault(require("../namespace-manager"));

var _ast = require("../parse/ast");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Property extends _node.default {
  constructor(node) {
    super(node);

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "skip", void 0);

    this.name = (0, _ast.parseNameFromNode)(node);
    this.skip = false;
  }

  skipNode() {
    this.skip = true;
  }

  print(namespace = "", mod = "root") {
    let out = "";
    let name = this.name;

    if (namespace) {
      _namespaceManager.default.registerProp(namespace, this.name);
    }

    if (namespace) {
      name = namespace + "$" + name;
    }

    if (this.raw.jsDoc) {
      out += _printers.default.common.comment(this.raw.jsDoc);
    }

    const isDeclare = mod !== "root";

    const exporter = _printers.default.relationships.exporter(this.raw);

    const modifier = exporter ? `${isDeclare ? "declare " : ""}${exporter}` : "declare ";
    if (this.skip) return out;

    switch (this.raw.kind) {
      case ts.SyntaxKind.FunctionDeclaration:
        out += _printers.default.functions.functionDeclaration(name, this.raw);
        break;

      case ts.SyntaxKind.ClassDeclaration:
        out += _printers.default.declarations.classDeclaration(name, this.raw);
        break;

      case ts.SyntaxKind.InterfaceDeclaration:
        out += _printers.default.declarations.interfaceDeclaration(name, this.raw, modifier);
        break;

      case ts.SyntaxKind.TypeAliasDeclaration:
        out += _printers.default.declarations.typeDeclaration(name, this.raw, modifier);
        break;

      case ts.SyntaxKind.EnumDeclaration:
        out += _printers.default.declarations.enumDeclaration(name, this.raw);
        break;

      case ts.SyntaxKind.VariableStatement:
        for (const decl of this.raw.declarationList.declarations) {
          if (namespace && decl.name.kind === ts.SyntaxKind.Identifier) {
            const text = decl.name.text;

            _namespaceManager.default.registerProp(namespace, text);
          }
        }

        out += _printers.default.declarations.variableDeclaration(this.raw);
        break;

      default:
        /*::;(this.raw.kind: empty)*/
        break;
    }

    return out;
  }

}

exports.default = Property;